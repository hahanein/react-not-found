import { jsx as _jsx } from "react/jsx-runtime";
import * as React from "react";
import Frame, { useFrame } from "react-frame-component";
import { MDXProvider } from "@mdx-js/react";
import ErrorBoundary from "./error-boundary";
import { stories, Provider } from "virtual:generated-list";
import { Ring } from "./icons";
import { ActionType } from "../../shared/types";
import config from "./get-config";
import StoryNotFound from "./story-not-found";
import { ModeState } from "../../shared/types";
import { CodeHighlight } from "./addons/source";
const StoryFrame = ({ children, active, width, story, mode, }) => {
    if ((!active && width === 0) || mode === ModeState.Preview)
        return children;
    return (_jsx(Frame, { title: `Story ${story}`, initialContent: `<!DOCTYPE html><html><head><base target="_parent" /></head><body style="margin:0"><div id="root"></div></body></html>`, mountTarget: "#root", className: "ladle-iframe", style: { width: width || "100%" }, children: children }));
};
// detecting parent's document.head changes, so we can apply the same CSS for
// the iframe, for CSS in JS we could target correct document directly but
// import './foo.css' always ends up in the parent only
const SynchronizeHead = ({ active, children, rtl, width, }) => {
    const { window: storyWindow } = useFrame();
    const syncHead = () => {
        if (!storyWindow)
            return;
        storyWindow.document.documentElement.setAttribute("dir", rtl ? "rtl" : "ltr");
        [...document.head.children].forEach((child) => {
            if (child.tagName === "STYLE" ||
                (child.tagName === "LINK" &&
                    (child.getAttribute("type") === "text/css" ||
                        child.getAttribute("rel") === "stylesheet"))) {
                storyWindow.document.head.appendChild(child.cloneNode(true));
            }
        });
    };
    React.useEffect(() => {
        if (active) {
            syncHead();
            const observer = new MutationObserver(() => syncHead());
            document.documentElement.setAttribute("data-iframed", `${width}`);
            observer.observe(document.head, {
                subtree: true,
                characterData: true,
                childList: true,
            });
            return () => {
                observer && observer.disconnect();
            };
        }
        return;
    }, [active, rtl]);
    return children;
};
const Story = ({ globalState, dispatch, }) => {
    const storyData = stories[globalState.story];
    const width = globalState.width;
    const storyDataMeta = storyData?.meta?.meta;
    const iframeActive = storyData && storyDataMeta ? storyDataMeta.iframed : false;
    let metaWidth = storyData && storyDataMeta ? storyDataMeta.width : 0;
    Object.keys(config.addons.width.options).forEach((key) => {
        if (key === metaWidth) {
            metaWidth = config.addons.width.options[key];
        }
    });
    React.useEffect(() => {
        if (metaWidth && metaWidth !== 0) {
            dispatch({ type: ActionType.UpdateWidth, value: metaWidth });
            return;
        }
        if (config.addons.width.defaultState !== 0) {
            dispatch({
                type: ActionType.UpdateWidth,
                value: config.addons.width.defaultState,
            });
        }
    }, [metaWidth, globalState.story]);
    React.useEffect(() => {
        if (globalState.mode !== ModeState.Preview && (iframeActive || width)) {
            document.documentElement.setAttribute("data-iframed", `${width}`);
        }
        else {
            document.documentElement.removeAttribute("data-iframed");
        }
    }, [iframeActive, globalState.story, globalState.mode, globalState.width]);
    if (!globalState.story) {
        return null;
    }
    return (_jsx(ErrorBoundary, { children: _jsx(React.Suspense, { fallback: _jsx(Ring, {}), children: _jsx(StoryFrame, { active: iframeActive, story: globalState.story, width: width, mode: globalState.mode, children: _jsx(SynchronizeHead, { active: (iframeActive || width > 0) &&
                        globalState.mode !== ModeState.Preview, rtl: globalState.rtl, width: width, children: _jsx(MDXProvider, { components: {
                            code: (props) => (_jsx(CodeHighlight, { ...props, theme: globalState.theme })),
                        }, children: _jsx(Provider, { config: config, globalState: globalState, dispatch: dispatch, storyMeta: storyDataMeta, children: storyData ? (React.createElement(storyData.component)) : (_jsx(StoryNotFound, { activeStory: globalState.story })) }) }) }) }) }) }));
};
export default Story;
